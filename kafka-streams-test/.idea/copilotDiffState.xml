<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="originalContent" value="FROM eclipse-temurin:17-jre-alpine&#10;&#10;WORKDIR /app&#10;&#10;# Copy the shaded JAR that includes all dependencies (ensures SLF4J binding is present)&#10;ARG JAR_FILE=target/*-shaded.jar&#10;COPY ${JAR_FILE} /app/app.jar&#10;&#10;# Ensure the log directory exists for Logback FileAppender&#10;RUN mkdir -p /app/logs&#10;&#10;# Optional: provide a default external YAML; can be overridden by a mounted file at runtime&#10;COPY src/main/resources/test.yaml /config/mapping.yaml&#10;&#10;# Configure the app&#10;ENV MAPPING_YAML_PATH=&quot;/config/mapping.yaml&quot;&#10;&#10;ENTRYPOINT [&quot;java&quot;, &quot;-Xmx3500m&quot;, &quot;-jar&quot;, &quot;/app/app.jar&quot;]" />
              <option name="updatedContent" value="FROM eclipse-temurin:17-jre-alpine&#10;&#10;WORKDIR /app&#10;&#10;# Copy the shaded JAR that includes all dependencies (ensures SLF4J binding is present)&#10;ARG JAR_FILE=target/*-shaded.jar&#10;COPY ${JAR_FILE} /app/app.jar&#10;&#10;# Ensure the log directory exists for Logback FileAppender&#10;RUN mkdir -p /app/logs&#10;&#10;# Optional: provide a default external YAML; can be overridden by a mounted file at runtime&#10;COPY src/main/resources/test.yaml /config/mapping.yaml&#10;&#10;# Configure the app&#10;ENV MAPPING_YAML_PATH=&quot;/config/mapping.yaml&quot;&#10;&#10;ENTRYPOINT [&quot;java&quot;, &quot;-Xmx3500m&quot;, &quot;-jar&quot;, &quot;/app/app.jar&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/example/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/example/Main.java" />
              <option name="originalContent" value="package org.example;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.File;&#10;import java.io.FileReader;&#10;import java.io.IOException;&#10;import java.lang.reflect.Field;&#10;import java.nio.file.Files;&#10;import java.nio.file.Paths;&#10;import java.util.Date;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Properties;&#10;import java.util.concurrent.CountDownLatch;&#10;&#10;import ca.uhn.fhir.context.FhirContext;&#10;import ca.uhn.fhir.context.support.DefaultProfileValidationSupport;&#10;import ca.uhn.fhir.sl.cache.CacheFactory;&#10;import ca.uhn.fhir.validation.FhirValidator;&#10;import ca.uhn.fhir.validation.IValidatorModule;&#10;import ca.uhn.fhir.validation.SchemaBaseValidator;&#10;import ca.uhn.fhir.validation.ValidationResult;&#10;import com.fasterxml.jackson.core.exc.StreamReadException;&#10;import com.fasterxml.jackson.databind.DatabindException;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;&#10;import com.google.gson.*;&#10;import lombok.Data;&#10;import netscape.javascript.JSObject;&#10;import org.apache.kafka.common.serialization.Serdes;&#10;import org.apache.kafka.streams.KafkaStreams;&#10;import org.apache.kafka.streams.StreamsBuilder;&#10;import org.apache.kafka.streams.StreamsConfig;&#10;import org.apache.kafka.streams.Topology;&#10;import org.apache.kafka.streams.kstream.KStream;&#10;import org.apache.kafka.streams.kstream.ValueMapper;&#10;// ADD these instead:&#10;import ca.uhn.fhir.context.support.IValidationSupport;&#10;import ca.uhn.fhir.context.support.ValidationSupportContext;&#10;import org.hl7.fhir.common.hapi.validation.support.CommonCodeSystemsTerminologyService;&#10;import org.hl7.fhir.common.hapi.validation.support.InMemoryTerminologyServerValidationSupport;&#10;import org.hl7.fhir.common.hapi.validation.support.SnapshotGeneratingValidationSupport;&#10;import org.hl7.fhir.common.hapi.validation.support.ValidationSupportChain;&#10;import org.hl7.fhir.common.hapi.validation.validator.FhirInstanceValidator;&#10;import org.hl7.fhir.r4.model.*;&#10;import org.hl7.fhir.r4.model.Bundle;&#10;import com.fasterxml.jackson.databind.JsonNode;&#10;import com.github.victools.jsonschema.generator.OptionPreset;&#10;import com.github.victools.jsonschema.generator.SchemaGenerator;&#10;import com.github.victools.jsonschema.generator.SchemaGeneratorConfig;&#10;import com.github.victools.jsonschema.generator.SchemaGeneratorConfigBuilder;&#10;import com.github.victools.jsonschema.generator.SchemaVersion;&#10;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;&#10;&#10;public class Main {&#10;&#10;    private static final Logger log = LoggerFactory.getLogger(Main.class);&#10;&#10;    // Rule describing how to map a source path to a target path and whether it's optional.&#10;    static class MappingRule {&#10;        final String target;&#10;        final boolean optional;&#10;        final ValueTransformer transformer; // extensible hook for future transformations&#10;&#10;        MappingRule(String target, boolean optional, ValueTransformer transformer) {&#10;            this.target = target;&#10;            this.optional = optional;&#10;            this.transformer = transformer == null ? ValueTransformer.identity() : transformer;&#10;        }&#10;    }&#10;&#10;    // Simple transformation functional interface to keep the pipeline extensible&#10;    interface ValueTransformer {&#10;        JsonElement apply(JsonElement in);&#10;&#10;        static ValueTransformer identity() {&#10;            return v -&gt; v;&#10;        }&#10;    }&#10;&#10;    // Token model for navigating/creating JSON structures&#10;    static abstract class PathToken {&#10;    }&#10;&#10;    static final class FieldToken extends PathToken {&#10;        final String name;&#10;&#10;        FieldToken(String n) {&#10;            this.name = n;&#10;        }&#10;    }&#10;&#10;    static final class IndexToken extends PathToken {&#10;        final int index;&#10;&#10;        IndexToken(int i) {&#10;            this.index = i;&#10;        }&#10;    }&#10;&#10;&#10;    final static String INPUT_TOPIC = &quot;wearables-raw&quot;;&#10;    final static String OUTPUT_TOPIC = &quot;wearables-fhri&quot;;&#10;    final static String KAFKA_BROKER_ENV_VAR = &quot;KAFKA_BROKER&quot;;&#10;    final static String APP_ID = &quot;fhri-mapper&quot;;&#10;    private static FhirValidator validator;&#10;    // Use a cached context and reuse it for parsing and validation&#10;    private static FhirContext CTX;&#10;&#10;    // We need to be able to choose between multiple yaml files for multiple providers&#10;    final static MappingYaml yaml = readYaml(&quot;src/main/resources/test.yaml&quot;);&#10;&#10;    //TODO we need to cahnge this so one input can produce multiple outputs&#10;    public static void main(String[] args) throws InterruptedException {&#10;&#10;        initiliazeFhirValidator();&#10;&#10;        StreamsBuilder builder = new StreamsBuilder();&#10;        KStream&lt;String, String&gt; lowerCaseStrings = builder.stream(INPUT_TOPIC);&#10;        KStream&lt;String, String&gt; upperCaseStrings = lowerCaseStrings.mapValues(new ValueMapper&lt;String, String&gt;() {&#10;            @Override&#10;            public String apply(String str) {&#10;                try {&#10;                    log.debug(&quot;Received message payload: {}&quot;, str);&#10;&#10;                    if (yaml == null || yaml.getMappingsList() == null) {&#10;                        log.error(&quot;There was an error reading the mapping yaml&quot;);&#10;                        return &quot;&quot;;&#10;                    }&#10;&#10;                    log.debug(&quot;Using yaml to transform: {}&quot;, yaml.getMappingsList().toString());&#10;                    JsonElement root = JsonParser.parseString(str);&#10;&#10;                    // Build mapping map from YAML: source -&gt; (target, optional)&#10;                    java.util.Map&lt;String, MappingRule&gt; rules = buildSourceRuleMap(yaml);&#10;&#10;                    // Traverse input and build output according to rules&#10;                    JsonObject output = new JsonObject();&#10;                    java.util.Set&lt;String&gt; foundSources = new java.util.HashSet&lt;&gt;();&#10;                    traverseAndApply(root, &quot;&quot;, output, rules, foundSources);&#10;&#10;                    // Verify that all non-optional mappings are present in input&#10;                    java.util.List&lt;String&gt; missingRequired = new java.util.ArrayList&lt;&gt;();&#10;                    for (java.util.Map.Entry&lt;String, MappingRule&gt; e : rules.entrySet()) {&#10;                        if (!e.getValue().optional &amp;&amp; !foundSources.contains(e.getKey())) {&#10;                            missingRequired.add(e.getKey());&#10;                        }&#10;                    }&#10;                    if (!missingRequired.isEmpty()) {&#10;                        String msg = &quot;Missing required fields in input for sources: &quot; + missingRequired;&#10;                        log.error(&quot;{} | foundSources={} rules={}&quot;, msg, foundSources, rules.keySet());&#10;                        throw new RuntimeException(msg);&#10;                    }&#10;&#10;                    String outStr = output.toString();&#10;                    log.debug(&quot;Produced mapped payload: {}&quot;, outStr);&#10;&#10;                    if (validate(outStr)) {&#10;                        return outStr;&#10;                    } else {&#10;                        return &quot;&quot;;&#10;                    }&#10;                } catch (Exception ex) {&#10;                    log.error(&quot;Transformation failed with exception&quot;, ex);&#10;                    return &quot;&quot;;&#10;                }&#10;            }&#10;        });&#10;        upperCaseStrings.to(OUTPUT_TOPIC);&#10;&#10;        Topology topology = builder.build();&#10;        KafkaStreams streamsApp = new KafkaStreams(topology, getKafkaStreamsConfig());&#10;        streamsApp.start();&#10;        log.info(&quot;Kafka Streams application '{}' started. Topology description:\n{}&quot;, APP_ID, topology.describe());&#10;&#10;        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {&#10;            log.info(&quot;Shutdown signal received. Closing Kafka Streams application '{}'...&quot;, APP_ID);&#10;            streamsApp.close();&#10;            log.info(&quot;Kafka Streams application '{}' closed.&quot;, APP_ID);&#10;        }));&#10;        new CountDownLatch(1).await();&#10;    }&#10;&#10;    private static void initiliazeFhirValidator() {&#10;&#10;        log.info(&quot;Initializing FHIR validator (with caching)...&quot;);&#10;        long start = System.currentTimeMillis();&#10;&#10;        // Use cached context to avoid repeated classpath scans&#10;        CTX = FhirContext.forR4Cached();&#10;        validator = CTX.newValidator();&#10;&#10;        ValidationSupportChain.CacheConfiguration.defaultValues();&#10;&#10;        // Build a local validation support chain and wrap it in a cache&#10;        ValidationSupportChain validationSupportChain = new ValidationSupportChain(&#10;                new DefaultProfileValidationSupport(CTX),&#10;                new CommonCodeSystemsTerminologyService(CTX),&#10;                new InMemoryTerminologyServerValidationSupport(CTX),&#10;                new SnapshotGeneratingValidationSupport(CTX)&#10;        );&#10;&#10;        fetchFhirStuff(validationSupportChain);&#10;&#10;        IValidatorModule module = new FhirInstanceValidator(validationSupportChain);&#10;        validator.registerValidatorModule(module);&#10;&#10;        long end = System.currentTimeMillis();&#10;        log.info(&quot;FHIR validator initialized in {} ms&quot;, (end - start));&#10;&#10;        // Pre-warm the caches with a minimal resource validation&#10;        try {&#10;            long warmStart = System.currentTimeMillis();&#10;            Patient p = new Patient();&#10;            p.addName().setFamily(&quot;warmup&quot;).addGiven(&quot;warm&quot;);&#10;            p.setId(&quot;warm-1&quot;);&#10;            ValidationResult warm = validator.validateWithResult(p);&#10;            long warmEnd = System.currentTimeMillis();&#10;            log.info(&quot;FHIR validator warm-up took {} ms, ok={}&quot;, (warmEnd - warmStart), warm.isSuccessful());&#10;        } catch (Exception e) {&#10;            log.warn(&quot;Warm-up validation failed: {}&quot;, e.getMessage());&#10;        }&#10;    }&#10;&#10;    // Build a map from source path -&gt; MappingRule (target, optional)&#10;    static java.util.Map&lt;String, MappingRule&gt; buildSourceRuleMap(MappingYaml yamlCfg) {&#10;        java.util.Map&lt;String, MappingRule&gt; map = new java.util.HashMap&lt;&gt;();&#10;        if (yamlCfg == null || yamlCfg.getMappingsList() == null) return map;&#10;        for (Mapping m : yamlCfg.getMappingsList()) {&#10;            if (m == null) continue;&#10;            String source = m.getSource() == null ? null : m.getSource().trim();&#10;            if (source == null || source.isEmpty()) continue;&#10;            String target = (m.getTarget() != null &amp;&amp; !m.getTarget().trim().isEmpty()) ? m.getTarget().trim() : source;&#10;            boolean optional = m.isOptional(); // defaults to false if missing&#10;            MappingRule rule = new MappingRule(target, optional, ValueTransformer.identity());&#10;            map.put(source, rule);&#10;        }&#10;        return map;&#10;    }&#10;&#10;    // Traverse input JSON and apply mapping rules where the current path matches a rule&#10;    static void traverseAndApply(JsonElement element,&#10;                                 String path,&#10;                                 JsonObject out,&#10;                                 java.util.Map&lt;String, MappingRule&gt; rules,&#10;                                 java.util.Set&lt;String&gt; foundSources) {&#10;        if (element == null || element.isJsonNull()) {&#10;            if (!path.isEmpty() &amp;&amp; rules.containsKey(path)) {&#10;                MappingRule r = rules.get(path);&#10;                log.debug(&quot;Applying mapping for null at path='{}' -&gt; target='{}' (optional={})&quot;, path, r.target, r.optional);&#10;                JsonElement transformed = r.transformer.apply(JsonNull.INSTANCE);&#10;                setAtTarget(out, r.target, transformed);&#10;                foundSources.add(path);&#10;            }&#10;            return;&#10;        }&#10;        if (element.isJsonPrimitive()) {&#10;            if (!path.isEmpty() &amp;&amp; rules.containsKey(path)) {&#10;                MappingRule r = rules.get(path);&#10;                log.debug(&quot;Applying mapping at primitive path='{}' -&gt; target='{}' (optional={}) value={}&quot;, path, r.target, r.optional, element);&#10;                JsonElement transformed = r.transformer.apply(element);&#10;                setAtTarget(out, r.target, transformed);&#10;                foundSources.add(path);&#10;            }&#10;            return;&#10;        }&#10;        if (element.isJsonArray()) {&#10;            JsonArray arr = element.getAsJsonArray();&#10;            for (int i = 0; i &lt; arr.size(); i++) {&#10;                String next = path.isEmpty() ? (&quot;[&quot; + i + &quot;]&quot;) : (path + &quot;[&quot; + i + &quot;]&quot;);&#10;                traverseAndApply(arr.get(i), next, out, rules, foundSources);&#10;            }&#10;            return;&#10;        }&#10;        if (element.isJsonObject()) {&#10;            JsonObject obj = element.getAsJsonObject();&#10;            for (java.util.Map.Entry&lt;String, JsonElement&gt; e : obj.entrySet()) {&#10;                String key = e.getKey();&#10;                JsonElement child = e.getValue();&#10;                String next = path.isEmpty() ? key : path + &quot;.&quot; + key;&#10;                traverseAndApply(child, next, out, rules, foundSources);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Set a value inside the output JsonObject according to a dot/[index] path, creating structures as needed&#10;    static void setAtTarget(JsonObject root, String targetPath, JsonElement value) {&#10;        java.util.List&lt;PathToken&gt; tokens = tokenize(targetPath);&#10;        if (tokens.isEmpty()) return;&#10;        JsonElement current = root;&#10;        for (int i = 0; i &lt; tokens.size(); i++) {&#10;            PathToken t = tokens.get(i);&#10;            boolean last = (i == tokens.size() - 1);&#10;            if (t instanceof FieldToken f) {&#10;                JsonObject obj = current.getAsJsonObject();&#10;                if (last) {&#10;                    log.debug(&quot;setAtTarget: setting field '{}' with value={} (last token)&quot;, f.name, value);&#10;                    obj.add(f.name, deepCopyElement(value));&#10;                } else {&#10;                    PathToken nextTok = tokens.get(i + 1);&#10;                    JsonElement next = obj.get(f.name);&#10;                    if (next == null || next.isJsonNull()) {&#10;                        next = (nextTok instanceof IndexToken) ? new JsonArray() : new JsonObject();&#10;                        obj.add(f.name, next);&#10;                        log.debug(&quot;setAtTarget: created {} for field '{}'&quot;, (nextTok instanceof IndexToken) ? &quot;JsonArray&quot; : &quot;JsonObject&quot;, f.name);&#10;                    }&#10;                    current = next;&#10;                }&#10;            } else if (t instanceof IndexToken idx) {&#10;                // current should be a JsonArray here&#10;                JsonArray arr;&#10;                if (current.isJsonArray()) {&#10;                    arr = current.getAsJsonArray();&#10;                } else {&#10;                    // Create array if current isn't array (edge case: target path starting with index)&#10;                    arr = new JsonArray();&#10;                    log.debug(&quot;setAtTarget: created JsonArray for index token at position {}&quot;, i);&#10;                    // We need a parent to attach this array; to keep code simple, we assume index isn't first token&#10;                    // If it is, we attach under a default key &quot;_root&quot;.&#10;                    // But normally, previous step ensures array container exists.&#10;                }&#10;                while (arr.size() &lt;= idx.index) arr.add(JsonNull.INSTANCE);&#10;                if (last) {&#10;                    log.debug(&quot;setAtTarget: setting array index {} with value={} (last token)&quot;, idx.index, value);&#10;                    arr.set(idx.index, deepCopyElement(value));&#10;                    current = arr.get(idx.index);&#10;                } else {&#10;                    PathToken nextTok = tokens.get(i + 1);&#10;                    JsonElement next = arr.get(idx.index);&#10;                    if (next == null || next.isJsonNull()) {&#10;                        next = (nextTok instanceof IndexToken) ? new JsonArray() : new JsonObject();&#10;                        arr.set(idx.index, next);&#10;                        log.debug(&quot;setAtTarget: created {} at array index {}&quot;, (nextTok instanceof IndexToken) ? &quot;JsonArray&quot; : &quot;JsonObject&quot;, idx.index);&#10;                    }&#10;                    current = next;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    static java.util.List&lt;PathToken&gt; tokenize(String path) {&#10;        java.util.ArrayList&lt;PathToken&gt; tokens = new java.util.ArrayList&lt;&gt;();&#10;        if (path == null || path.isBlank()) return tokens;&#10;        StringBuilder sb = new StringBuilder();&#10;        for (int i = 0; i &lt; path.length(); i++) {&#10;            char c = path.charAt(i);&#10;            if (c == '.') {&#10;                if (sb.length() &gt; 0) {&#10;                    tokens.add(new FieldToken(sb.toString()));&#10;                    sb.setLength(0);&#10;                }&#10;            } else if (c == '[') {&#10;                if (sb.length() &gt; 0) {&#10;                    tokens.add(new FieldToken(sb.toString()));&#10;                    sb.setLength(0);&#10;                }&#10;                int j = i + 1;&#10;                int num = 0;&#10;                while (j &lt; path.length() &amp;&amp; Character.isDigit(path.charAt(j))) {&#10;                    num = num * 10 + (path.charAt(j) - '0');&#10;                    j++;&#10;                }&#10;                // expect closing ']'&#10;                if (j &lt; path.length() &amp;&amp; path.charAt(j) == ']') {&#10;                    tokens.add(new IndexToken(num));&#10;                    i = j; // advance&#10;                } else {&#10;                    // malformed, treat as literal&#10;                    tokens.add(new FieldToken(&quot;[&quot;));&#10;                }&#10;            } else {&#10;                sb.append(c);&#10;            }&#10;        }&#10;        if (sb.length() &gt; 0) {&#10;            tokens.add(new FieldToken(sb.toString()));&#10;        }&#10;        return tokens;&#10;    }&#10;&#10;    static JsonElement deepCopyElement(JsonElement in) {&#10;        if (in == null) return JsonNull.INSTANCE;&#10;        try {&#10;            return JsonParser.parseString(in.toString());&#10;        } catch (Exception e) {&#10;            return in; // fallback&#10;        }&#10;    }&#10;&#10;    static Properties getKafkaStreamsConfig() {&#10;&#10;        // Read broker info from environment variable KAFKA_BROKER&#10;        String envValue = System.getenv(KAFKA_BROKER_ENV_VAR);&#10;&#10;        String bootstrapServers;&#10;        if (envValue == null || envValue.trim().isEmpty()) {&#10;            // Fallback to sensible default&#10;            bootstrapServers = &quot;localhost:9092&quot;;&#10;            log.warn(&quot;Env var '{}' not set. Using default bootstrap servers: {}&quot;, KAFKA_BROKER_ENV_VAR, bootstrapServers);&#10;        } else {&#10;            String trimmed = envValue.trim();&#10;            // If the value already looks like a full bootstrap servers string (contains ':' or commas), use as-is&#10;            if (trimmed.contains(&quot;:&quot;) || trimmed.contains(&quot;,&quot;)) {&#10;                bootstrapServers = trimmed;&#10;            } else {&#10;                // Treat it as a host and append the default Kafka port&#10;                bootstrapServers = trimmed + &quot;:9092&quot;;&#10;            }&#10;            log.info(&quot;Using bootstrap servers from env '{}': {}&quot;, KAFKA_BROKER_ENV_VAR, bootstrapServers);&#10;        }&#10;&#10;        Properties configurations = new Properties();&#10;&#10;        configurations.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);&#10;        configurations.put(StreamsConfig.APPLICATION_ID_CONFIG, APP_ID);&#10;        configurations.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, org.apache.kafka.common.serialization.Serdes.String().getClass().getName());&#10;        configurations.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, org.apache.kafka.common.serialization.Serdes.String().getClass().getName());&#10;&#10;        configurations.put(StreamsConfig.REQUEST_TIMEOUT_MS_CONFIG, &quot;20000&quot;);&#10;        configurations.put(StreamsConfig.RETRY_BACKOFF_MS_CONFIG, &quot;500&quot;);&#10;&#10;        return configurations;&#10;    }&#10;&#10;    static boolean validate(String producedStr){&#10;&#10;        try {&#10;            // Parse once to avoid internal re-parsing costs and validate the resource instance&#10;            var parser = CTX.newJsonParser();&#10;            var resource = parser.parseResource(producedStr);&#10;            ValidationResult result = validator.validateWithResult(resource);&#10;            log.info(&quot;Validation result: {}&quot;, result.toString());&#10;            return result.isSuccessful();&#10;        } catch (Exception e) {&#10;            log.error(&quot;Validation failed (input may not be a valid FHIR resource).&quot;, e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    //for debugging&#10;    static void fetchFhirStuff(ValidationSupportChain dpvs) {&#10;        if (dpvs == null) {&#10;            log.error(&quot;DefaultProfileValidationSupport (dpvs) is null.&quot;);&#10;            return;&#10;        }&#10;&#10;        Object conformanceResources = dpvs.fetchAllConformanceResources();&#10;        if (conformanceResources != null) {&#10;            log.info(&quot;Conformance resources: {}&quot;, conformanceResources.toString());&#10;        } else {&#10;            log.warn(&quot;Conformance resources are null.&quot;);&#10;        }&#10;&#10;        Object nonBaseStructureDefs = dpvs.fetchAllNonBaseStructureDefinitions();&#10;        if (nonBaseStructureDefs != null) {&#10;            log.info(&quot;Non base structure definitions: {}&quot;, nonBaseStructureDefs.toString());&#10;        } else {&#10;            log.warn(&quot;Non base structure definitions are null.&quot;);&#10;        }&#10;&#10;//        Object searchParameters = dpvs.fetchAllSearchParameters();&#10;//        if (searchParameters != null) {&#10;//            SLog.i(&quot;Search parameters: %s&quot;, searchParameters.toString());&#10;//        } else {&#10;//            SLog.w(&quot;Search parameters are null.&quot;);&#10;//        }&#10;&#10;        Object name = dpvs.getName();&#10;        if (name != null) {&#10;            log.info(&quot;Name: {}&quot;, name.toString());&#10;        } else {&#10;            log.warn(&quot;Name is null.&quot;);&#10;        }&#10;    }&#10;&#10;    // We read the provided YAML from the user and check if it's fits the requirements of the &quot;meta-yaml&quot;.&#10;    // We only have to do this once in the beginning since I propose we restart the tasks / pods after we added a new provider&#10;    static MappingYaml readYaml(String path) {&#10;&#10;        // TODO validate the user yaml somehow&#10;        ObjectMapper mapper = new ObjectMapper(new YAMLFactory());&#10;&#10;        mapper.findAndRegisterModules();&#10;&#10;        String externalPath = System.getenv(&quot;MAPPING_YAML_PATH&quot;);&#10;        try {&#10;            log.info(&quot;Loading YAML from external path: {}&quot;, externalPath);&#10;&#10;            String content = Files.readString(Paths.get(externalPath));&#10;            System.out.println(&quot;YAML content:\n&quot; + content);&#10;&#10;            MappingYaml t = mapper.readValue(new File(externalPath), MappingYaml.class);&#10;&#10;            if (t == null){&#10;                log.debug(&quot;t is null&quot;);&#10;            } else if (t.getMappingsList() == null){&#10;                log.debug(&quot;list is null, t is {}&quot;, t);&#10;            }&#10;            return t;&#10;        } catch (IOException e) {&#10;            log.error(String.format(&quot;Failed to load mapping YAML (externalPath=%s, providedPath=%s)&quot;, externalPath, path), e);&#10;            throw new RuntimeException(&quot;Failed to load mapping YAML: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;}&#10;&#10;@Data&#10;class MappingYaml {&#10;    private List&lt;Mapping&gt; mappingsList;&#10;}&#10;&#10;// Mapping represents one mapping from a type in the Input to a type in the output&#10;@Data&#10;class Mapping {&#10;    private String source;&#10;    private String target; // optional in yaml; defaults to source when null&#10;    private String type;&#10;    private boolean optional;&#10;}&#10;" />
              <option name="updatedContent" value="package org.example;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.File;&#10;import java.io.FileReader;&#10;import java.io.IOException;&#10;import java.lang.reflect.Field;&#10;import java.nio.file.Files;&#10;import java.nio.file.Paths;&#10;import java.util.Date;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Properties;&#10;import java.util.concurrent.CountDownLatch;&#10;&#10;import ca.uhn.fhir.context.FhirContext;&#10;import ca.uhn.fhir.context.support.DefaultProfileValidationSupport;&#10;import ca.uhn.fhir.sl.cache.CacheFactory;&#10;import ca.uhn.fhir.validation.FhirValidator;&#10;import ca.uhn.fhir.validation.IValidatorModule;&#10;import ca.uhn.fhir.validation.SchemaBaseValidator;&#10;import ca.uhn.fhir.validation.ValidationResult;&#10;import com.fasterxml.jackson.core.exc.StreamReadException;&#10;import com.fasterxml.jackson.databind.DatabindException;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;&#10;import com.google.gson.*;&#10;import lombok.Data;&#10;import netscape.javascript.JSObject;&#10;import org.apache.kafka.common.serialization.Serdes;&#10;import org.apache.kafka.streams.KafkaStreams;&#10;import org.apache.kafka.streams.StreamsBuilder;&#10;import org.apache.kafka.streams.StreamsConfig;&#10;import org.apache.kafka.streams.Topology;&#10;import org.apache.kafka.streams.kstream.KStream;&#10;import org.apache.kafka.streams.kstream.ValueMapper;&#10;// ADD these instead:&#10;import ca.uhn.fhir.context.support.IValidationSupport;&#10;import ca.uhn.fhir.context.support.ValidationSupportContext;&#10;import org.hl7.fhir.common.hapi.validation.support.CommonCodeSystemsTerminologyService;&#10;import org.hl7.fhir.common.hapi.validation.support.InMemoryTerminologyServerValidationSupport;&#10;import org.hl7.fhir.common.hapi.validation.support.SnapshotGeneratingValidationSupport;&#10;import org.hl7.fhir.common.hapi.validation.support.ValidationSupportChain;&#10;import org.hl7.fhir.common.hapi.validation.validator.FhirInstanceValidator;&#10;import org.hl7.fhir.r4.model.*;&#10;import org.hl7.fhir.r4.model.Bundle;&#10;import com.fasterxml.jackson.databind.JsonNode;&#10;import com.github.victools.jsonschema.generator.OptionPreset;&#10;import com.github.victools.jsonschema.generator.SchemaGenerator;&#10;import com.github.victools.jsonschema.generator.SchemaGeneratorConfig;&#10;import com.github.victools.jsonschema.generator.SchemaGeneratorConfigBuilder;&#10;import com.github.victools.jsonschema.generator.SchemaVersion;&#10;import com.fasterxml.jackson.annotation.JsonIgnoreProperties;&#10;&#10;public class Main {&#10;&#10;    private static final Logger log = LoggerFactory.getLogger(Main.class);&#10;&#10;    // Rule describing how to map a source path to a target path and whether it's optional.&#10;    static class MappingRule {&#10;        final String target;&#10;        final boolean optional;&#10;        final ValueTransformer transformer; // extensible hook for future transformations&#10;&#10;        MappingRule(String target, boolean optional, ValueTransformer transformer) {&#10;            this.target = target;&#10;            this.optional = optional;&#10;            this.transformer = transformer == null ? ValueTransformer.identity() : transformer;&#10;        }&#10;    }&#10;&#10;    // Simple transformation functional interface to keep the pipeline extensible&#10;    interface ValueTransformer {&#10;        JsonElement apply(JsonElement in);&#10;&#10;        static ValueTransformer identity() {&#10;            return v -&gt; v;&#10;        }&#10;    }&#10;&#10;    // Token model for navigating/creating JSON structures&#10;    static abstract class PathToken {&#10;    }&#10;&#10;    static final class FieldToken extends PathToken {&#10;        final String name;&#10;&#10;        FieldToken(String n) {&#10;            this.name = n;&#10;        }&#10;    }&#10;&#10;    static final class IndexToken extends PathToken {&#10;        final int index;&#10;&#10;        IndexToken(int i) {&#10;            this.index = i;&#10;        }&#10;    }&#10;&#10;&#10;    final static String INPUT_TOPIC = &quot;wearables-raw&quot;;&#10;    final static String OUTPUT_TOPIC = &quot;wearables-fhri&quot;;&#10;    final static String KAFKA_BROKER_ENV_VAR = &quot;KAFKA_BROKER&quot;;&#10;    final static String APP_ID = &quot;fhri-mapper&quot;;&#10;    private static FhirValidator validator;&#10;    // Use a cached context and reuse it for parsing and validation&#10;    private static FhirContext CTX;&#10;&#10;    // We need to be able to choose between multiple yaml files for multiple providers&#10;    final static MappingYaml yaml = readYaml(&quot;src/main/resources/test.yaml&quot;);&#10;&#10;    //TODO we need to cahnge this so one input can produce multiple outputs&#10;    public static void main(String[] args) throws InterruptedException {&#10;&#10;        initiliazeFhirValidator();&#10;&#10;        StreamsBuilder builder = new StreamsBuilder();&#10;        KStream&lt;String, String&gt; lowerCaseStrings = builder.stream(INPUT_TOPIC);&#10;        KStream&lt;String, String&gt; upperCaseStrings = lowerCaseStrings.mapValues(new ValueMapper&lt;String, String&gt;() {&#10;            @Override&#10;            public String apply(String str) {&#10;                try {&#10;                    log.debug(&quot;Received message payload: {}&quot;, str);&#10;&#10;                    if (yaml == null || yaml.getMappingsList() == null) {&#10;                        log.error(&quot;There was an error reading the mapping yaml&quot;);&#10;                        return &quot;&quot;;&#10;                    }&#10;&#10;                    log.debug(&quot;Using yaml to transform: {}&quot;, yaml.getMappingsList().toString());&#10;                    JsonElement root = JsonParser.parseString(str);&#10;&#10;                    // Build mapping map from YAML: source -&gt; (target, optional)&#10;                    java.util.Map&lt;String, MappingRule&gt; rules = buildSourceRuleMap(yaml);&#10;&#10;                    // Traverse input and build output according to rules&#10;                    JsonObject output = new JsonObject();&#10;                    java.util.Set&lt;String&gt; foundSources = new java.util.HashSet&lt;&gt;();&#10;                    traverseAndApply(root, &quot;&quot;, output, rules, foundSources);&#10;&#10;                    // Verify that all non-optional mappings are present in input&#10;                    java.util.List&lt;String&gt; missingRequired = new java.util.ArrayList&lt;&gt;();&#10;                    for (java.util.Map.Entry&lt;String, MappingRule&gt; e : rules.entrySet()) {&#10;                        if (!e.getValue().optional &amp;&amp; !foundSources.contains(e.getKey())) {&#10;                            missingRequired.add(e.getKey());&#10;                        }&#10;                    }&#10;                    if (!missingRequired.isEmpty()) {&#10;                        String msg = &quot;Missing required fields in input for sources: &quot; + missingRequired;&#10;                        log.error(&quot;{} | foundSources={} rules={}&quot;, msg, foundSources, rules.keySet());&#10;                        throw new RuntimeException(msg);&#10;                    }&#10;&#10;                    String outStr = output.toString();&#10;                    log.debug(&quot;Produced mapped payload: {}&quot;, outStr);&#10;&#10;                    if (validate(outStr)) {&#10;                        return outStr;&#10;                    } else {&#10;                        return &quot;&quot;;&#10;                    }&#10;                } catch (Exception ex) {&#10;                    log.error(&quot;Transformation failed with exception&quot;, ex);&#10;                    return &quot;&quot;;&#10;                }&#10;            }&#10;        });&#10;        upperCaseStrings.to(OUTPUT_TOPIC);&#10;&#10;        Topology topology = builder.build();&#10;        KafkaStreams streamsApp = new KafkaStreams(topology, getKafkaStreamsConfig());&#10;        streamsApp.start();&#10;        log.info(&quot;Kafka Streams application '{}' started. Topology description:\n{}&quot;, APP_ID, topology.describe());&#10;&#10;        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {&#10;            log.info(&quot;Shutdown signal received. Closing Kafka Streams application '{}'...&quot;, APP_ID);&#10;            streamsApp.close();&#10;            log.info(&quot;Kafka Streams application '{}' closed.&quot;, APP_ID);&#10;        }));&#10;        new CountDownLatch(1).await();&#10;    }&#10;&#10;    private static void initiliazeFhirValidator() {&#10;&#10;        log.info(&quot;Initializing FHIR validator (with caching)...&quot;);&#10;        long start = System.currentTimeMillis();&#10;&#10;        // Use cached context to avoid repeated classpath scans&#10;        CTX = FhirContext.forR4Cached();&#10;        validator = CTX.newValidator();&#10;&#10;        ValidationSupportChain.CacheConfiguration.defaultValues();&#10;&#10;        // Build a local validation support chain and wrap it in a cache&#10;        ValidationSupportChain validationSupportChain = new ValidationSupportChain(&#10;                new DefaultProfileValidationSupport(CTX),&#10;                new CommonCodeSystemsTerminologyService(CTX),&#10;                new InMemoryTerminologyServerValidationSupport(CTX),&#10;                new SnapshotGeneratingValidationSupport(CTX)&#10;        );&#10;&#10;        fetchFhirStuff(validationSupportChain);&#10;&#10;        IValidatorModule module = new FhirInstanceValidator(validationSupportChain);&#10;        validator.registerValidatorModule(module);&#10;&#10;        long end = System.currentTimeMillis();&#10;        log.info(&quot;FHIR validator initialized in {} ms&quot;, (end - start));&#10;&#10;        // Pre-warm the caches with a minimal resource validation&#10;        try {&#10;            long warmStart = System.currentTimeMillis();&#10;            Patient p = new Patient();&#10;            p.addName().setFamily(&quot;warmup&quot;).addGiven(&quot;warm&quot;);&#10;            p.setId(&quot;warm-1&quot;);&#10;            ValidationResult warm = validator.validateWithResult(p);&#10;            long warmEnd = System.currentTimeMillis();&#10;            log.info(&quot;FHIR validator warm-up took {} ms, ok={}&quot;, (warmEnd - warmStart), warm.isSuccessful());&#10;        } catch (Exception e) {&#10;            log.warn(&quot;Warm-up validation failed: {}&quot;, e.getMessage());&#10;        }&#10;    }&#10;&#10;    // Build a map from source path -&gt; MappingRule (target, optional)&#10;    static java.util.Map&lt;String, MappingRule&gt; buildSourceRuleMap(MappingYaml yamlCfg) {&#10;        java.util.Map&lt;String, MappingRule&gt; map = new java.util.HashMap&lt;&gt;();&#10;        if (yamlCfg == null || yamlCfg.getMappingsList() == null) return map;&#10;        for (Mapping m : yamlCfg.getMappingsList()) {&#10;            if (m == null) continue;&#10;            String source = m.getSource() == null ? null : m.getSource().trim();&#10;            if (source == null || source.isEmpty()) continue;&#10;            String target = (m.getTarget() != null &amp;&amp; !m.getTarget().trim().isEmpty()) ? m.getTarget().trim() : source;&#10;            boolean optional = m.isOptional(); // defaults to false if missing&#10;            MappingRule rule = new MappingRule(target, optional, ValueTransformer.identity());&#10;            map.put(source, rule);&#10;        }&#10;        return map;&#10;    }&#10;&#10;    // Traverse input JSON and apply mapping rules where the current path matches a rule&#10;    static void traverseAndApply(JsonElement element,&#10;                                 String path,&#10;                                 JsonObject out,&#10;                                 java.util.Map&lt;String, MappingRule&gt; rules,&#10;                                 java.util.Set&lt;String&gt; foundSources) {&#10;        if (element == null || element.isJsonNull()) {&#10;            if (!path.isEmpty() &amp;&amp; rules.containsKey(path)) {&#10;                MappingRule r = rules.get(path);&#10;                log.debug(&quot;Applying mapping for null at path='{}' -&gt; target='{}' (optional={})&quot;, path, r.target, r.optional);&#10;                JsonElement transformed = r.transformer.apply(JsonNull.INSTANCE);&#10;                setAtTarget(out, r.target, transformed);&#10;                foundSources.add(path);&#10;            }&#10;            return;&#10;        }&#10;        if (element.isJsonPrimitive()) {&#10;            if (!path.isEmpty() &amp;&amp; rules.containsKey(path)) {&#10;                MappingRule r = rules.get(path);&#10;                log.debug(&quot;Applying mapping at primitive path='{}' -&gt; target='{}' (optional={}) value={}&quot;, path, r.target, r.optional, element);&#10;                JsonElement transformed = r.transformer.apply(element);&#10;                setAtTarget(out, r.target, transformed);&#10;                foundSources.add(path);&#10;            }&#10;            return;&#10;        }&#10;        if (element.isJsonArray()) {&#10;            JsonArray arr = element.getAsJsonArray();&#10;            for (int i = 0; i &lt; arr.size(); i++) {&#10;                String next = path.isEmpty() ? (&quot;[&quot; + i + &quot;]&quot;) : (path + &quot;[&quot; + i + &quot;]&quot;);&#10;                traverseAndApply(arr.get(i), next, out, rules, foundSources);&#10;            }&#10;            return;&#10;        }&#10;        if (element.isJsonObject()) {&#10;            JsonObject obj = element.getAsJsonObject();&#10;            for (java.util.Map.Entry&lt;String, JsonElement&gt; e : obj.entrySet()) {&#10;                String key = e.getKey();&#10;                JsonElement child = e.getValue();&#10;                String next = path.isEmpty() ? key : path + &quot;.&quot; + key;&#10;                traverseAndApply(child, next, out, rules, foundSources);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Set a value inside the output JsonObject according to a dot/[index] path, creating structures as needed&#10;    static void setAtTarget(JsonObject root, String targetPath, JsonElement value) {&#10;        java.util.List&lt;PathToken&gt; tokens = tokenize(targetPath);&#10;        if (tokens.isEmpty()) return;&#10;        JsonElement current = root;&#10;        for (int i = 0; i &lt; tokens.size(); i++) {&#10;            PathToken t = tokens.get(i);&#10;            boolean last = (i == tokens.size() - 1);&#10;            if (t instanceof FieldToken f) {&#10;                JsonObject obj = current.getAsJsonObject();&#10;                if (last) {&#10;                    log.debug(&quot;setAtTarget: setting field '{}' with value={} (last token)&quot;, f.name, value);&#10;                    obj.add(f.name, deepCopyElement(value));&#10;                } else {&#10;                    PathToken nextTok = tokens.get(i + 1);&#10;                    JsonElement next = obj.get(f.name);&#10;                    if (next == null || next.isJsonNull()) {&#10;                        next = (nextTok instanceof IndexToken) ? new JsonArray() : new JsonObject();&#10;                        obj.add(f.name, next);&#10;                        log.debug(&quot;setAtTarget: created {} for field '{}'&quot;, (nextTok instanceof IndexToken) ? &quot;JsonArray&quot; : &quot;JsonObject&quot;, f.name);&#10;                    }&#10;                    current = next;&#10;                }&#10;            } else if (t instanceof IndexToken idx) {&#10;                // current should be a JsonArray here&#10;                JsonArray arr;&#10;                if (current.isJsonArray()) {&#10;                    arr = current.getAsJsonArray();&#10;                } else {&#10;                    // Create array if current isn't array (edge case: target path starting with index)&#10;                    arr = new JsonArray();&#10;                    log.debug(&quot;setAtTarget: created JsonArray for index token at position {}&quot;, i);&#10;                    // We need a parent to attach this array; to keep code simple, we assume index isn't first token&#10;                    // If it is, we attach under a default key &quot;_root&quot;.&#10;                    // But normally, previous step ensures array container exists.&#10;                }&#10;                while (arr.size() &lt;= idx.index) arr.add(JsonNull.INSTANCE);&#10;                if (last) {&#10;                    log.debug(&quot;setAtTarget: setting array index {} with value={} (last token)&quot;, idx.index, value);&#10;                    arr.set(idx.index, deepCopyElement(value));&#10;                    current = arr.get(idx.index);&#10;                } else {&#10;                    PathToken nextTok = tokens.get(i + 1);&#10;                    JsonElement next = arr.get(idx.index);&#10;                    if (next == null || next.isJsonNull()) {&#10;                        next = (nextTok instanceof IndexToken) ? new JsonArray() : new JsonObject();&#10;                        arr.set(idx.index, next);&#10;                        log.debug(&quot;setAtTarget: created {} at array index {}&quot;, (nextTok instanceof IndexToken) ? &quot;JsonArray&quot; : &quot;JsonObject&quot;, idx.index);&#10;                    }&#10;                    current = next;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    static java.util.List&lt;PathToken&gt; tokenize(String path) {&#10;        java.util.ArrayList&lt;PathToken&gt; tokens = new java.util.ArrayList&lt;&gt;();&#10;        if (path == null || path.isBlank()) return tokens;&#10;        StringBuilder sb = new StringBuilder();&#10;        for (int i = 0; i &lt; path.length(); i++) {&#10;            char c = path.charAt(i);&#10;            if (c == '.') {&#10;                if (sb.length() &gt; 0) {&#10;                    tokens.add(new FieldToken(sb.toString()));&#10;                    sb.setLength(0);&#10;                }&#10;            } else if (c == '[') {&#10;                if (sb.length() &gt; 0) {&#10;                    tokens.add(new FieldToken(sb.toString()));&#10;                    sb.setLength(0);&#10;                }&#10;                int j = i + 1;&#10;                int num = 0;&#10;                while (j &lt; path.length() &amp;&amp; Character.isDigit(path.charAt(j))) {&#10;                    num = num * 10 + (path.charAt(j) - '0');&#10;                    j++;&#10;                }&#10;                // expect closing ']'&#10;                if (j &lt; path.length() &amp;&amp; path.charAt(j) == ']') {&#10;                    tokens.add(new IndexToken(num));&#10;                    i = j; // advance&#10;                } else {&#10;                    // malformed, treat as literal&#10;                    tokens.add(new FieldToken(&quot;[&quot;));&#10;                }&#10;            } else {&#10;                sb.append(c);&#10;            }&#10;        }&#10;        if (sb.length() &gt; 0) {&#10;            tokens.add(new FieldToken(sb.toString()));&#10;        }&#10;        return tokens;&#10;    }&#10;&#10;    static JsonElement deepCopyElement(JsonElement in) {&#10;        if (in == null) return JsonNull.INSTANCE;&#10;        try {&#10;            return JsonParser.parseString(in.toString());&#10;        } catch (Exception e) {&#10;            return in; // fallback&#10;        }&#10;    }&#10;&#10;    static Properties getKafkaStreamsConfig() {&#10;&#10;        // Read broker info from environment variable KAFKA_BROKER&#10;        String envValue = System.getenv(KAFKA_BROKER_ENV_VAR);&#10;&#10;        String bootstrapServers;&#10;        if (envValue == null || envValue.trim().isEmpty()) {&#10;            // Fallback to sensible default&#10;            bootstrapServers = &quot;localhost:9092&quot;;&#10;            log.warn(&quot;Env var '{}' not set. Using default bootstrap servers: {}&quot;, KAFKA_BROKER_ENV_VAR, bootstrapServers);&#10;        } else {&#10;            String trimmed = envValue.trim();&#10;            // If the value already looks like a full bootstrap servers string (contains ':' or commas), use as-is&#10;            if (trimmed.contains(&quot;:&quot;) || trimmed.contains(&quot;,&quot;)) {&#10;                bootstrapServers = trimmed;&#10;            } else {&#10;                // Treat it as a host and append the default Kafka port&#10;                bootstrapServers = trimmed + &quot;:9092&quot;;&#10;            }&#10;            log.info(&quot;Using bootstrap servers from env '{}': {}&quot;, KAFKA_BROKER_ENV_VAR, bootstrapServers);&#10;        }&#10;&#10;        Properties configurations = new Properties();&#10;&#10;        configurations.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);&#10;        configurations.put(StreamsConfig.APPLICATION_ID_CONFIG, APP_ID);&#10;        configurations.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, org.apache.kafka.common.serialization.Serdes.String().getClass().getName());&#10;        configurations.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, org.apache.kafka.common.serialization.Serdes.String().getClass().getName());&#10;&#10;        configurations.put(StreamsConfig.REQUEST_TIMEOUT_MS_CONFIG, &quot;20000&quot;);&#10;        configurations.put(StreamsConfig.RETRY_BACKOFF_MS_CONFIG, &quot;500&quot;);&#10;&#10;        return configurations;&#10;    }&#10;&#10;    static boolean validate(String producedStr){&#10;&#10;        try {&#10;            // Parse once to avoid internal re-parsing costs and validate the resource instance&#10;            var parser = CTX.newJsonParser();&#10;            var resource = parser.parseResource(producedStr);&#10;            ValidationResult result = validator.validateWithResult(resource);&#10;            log.info(&quot;Validation result: {}&quot;, result.toString());&#10;            return result.isSuccessful();&#10;        } catch (Exception e) {&#10;            log.error(&quot;Validation failed (input may not be a valid FHIR resource).&quot;, e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    //for debugging&#10;    static void fetchFhirStuff(ValidationSupportChain dpvs) {&#10;        if (dpvs == null) {&#10;            log.error(&quot;DefaultProfileValidationSupport (dpvs) is null.&quot;);&#10;            return;&#10;        }&#10;&#10;        Object conformanceResources = dpvs.fetchAllConformanceResources();&#10;        if (conformanceResources != null) {&#10;            log.info(&quot;Conformance resources: {}&quot;, conformanceResources.toString());&#10;        } else {&#10;            log.warn(&quot;Conformance resources are null.&quot;);&#10;        }&#10;&#10;        Object nonBaseStructureDefs = dpvs.fetchAllNonBaseStructureDefinitions();&#10;        if (nonBaseStructureDefs != null) {&#10;            log.info(&quot;Non base structure definitions: {}&quot;, nonBaseStructureDefs.toString());&#10;        } else {&#10;            log.warn(&quot;Non base structure definitions are null.&quot;);&#10;        }&#10;&#10;//        Object searchParameters = dpvs.fetchAllSearchParameters();&#10;//        if (searchParameters != null) {&#10;//            SLog.i(&quot;Search parameters: %s&quot;, searchParameters.toString());&#10;//        } else {&#10;//            SLog.w(&quot;Search parameters are null.&quot;);&#10;//        }&#10;&#10;        Object name = dpvs.getName();&#10;        if (name != null) {&#10;            log.info(&quot;Name: {}&quot;, name.toString());&#10;        } else {&#10;            log.warn(&quot;Name is null.&quot;);&#10;        }&#10;    }&#10;&#10;    // We read the provided YAML from the user and check if it's fits the requirements of the &quot;meta-yaml&quot;.&#10;    // We only have to do this once in the beginning since I propose we restart the tasks / pods after we added a new provider&#10;    static MappingYaml readYaml(String path) {&#10;&#10;        // TODO validate the user yaml somehow&#10;        ObjectMapper mapper = new ObjectMapper(new YAMLFactory());&#10;&#10;        mapper.findAndRegisterModules();&#10;&#10;        String externalPath = System.getenv(&quot;MAPPING_YAML_PATH&quot;);&#10;        try {&#10;            log.info(&quot;Loading YAML from external path: {}&quot;, externalPath);&#10;&#10;            String content = Files.readString(Paths.get(externalPath));&#10;            System.out.println(&quot;YAML content:\n&quot; + content);&#10;&#10;            MappingYaml t = mapper.readValue(new File(externalPath), MappingYaml.class);&#10;&#10;            if (t == null){&#10;                log.debug(&quot;t is null&quot;);&#10;            } else if (t.getMappingsList() == null){&#10;                log.debug(&quot;list is null, t is {}&quot;, t);&#10;            }&#10;            return t;&#10;        } catch (IOException e) {&#10;            log.error(String.format(&quot;Failed to load mapping YAML (externalPath=%s, providedPath=%s)&quot;, externalPath, path), e);&#10;            throw new RuntimeException(&quot;Failed to load mapping YAML: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;}&#10;&#10;@Data&#10;class MappingYaml {&#10;    private List&lt;Mapping&gt; mappingsList;&#10;}&#10;&#10;// Mapping represents one mapping from a type in the Input to a type in the output&#10;@Data&#10;class Mapping {&#10;    private String source;&#10;    private String target; // optional in yaml; defaults to source when null&#10;    private String type;&#10;    private boolean optional;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>